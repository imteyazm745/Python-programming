Variable:  
A variable is basically nothing but the name of a memory location that we use for storing data. We can change the value of a variable in C or any other language, and we can also reuse it multiple times.

Creating a Variable:  
checkingAccount = 500
savingsAccount = 1000

# add 100 to our savings (Yeah!)
savingsAccount = savingsAccount + 100

# remove 50 from our checkingaccount (Sniff)
checkingAccount = checkingAccount - 50

# calculate the number of days to save to reach 5000
numberDaysSave = (5000 - checkingAccount) / 500

# update our checkingaccount (again) after the daily gains/losses
checkingAccount = checkingAccount + (30 - 10) * 7
Lines starting with a # are comments. They are used to document your code and help others understand it.
The other lines of code (which can run operations, declarations, etc.) are expressions. They tell the computer what to do.
each of the expressions assigns a value to a variable. The assignment operator is   = .
To the right of the assignment operator is the expression that will create/calculate a value.
To the left of the assignment operator, you write the name of the variable to which you will assign the corresponding value.

There are also other arithmetic operators that are a little more complex, but nevertheless useful, such as:
% modulo : returns the remainder of the euclidean division
** power : raises a number to a certain power
// integer division: calculates the integer division (rounded down)
print(SavingsAccount % 500) # -> 100
# 1100 = 500 * 2 + 100, so 1100 % 500 = remainder = 100
print(9 ** 3) # -> 729, 9*9*9 = 729
print(SavingsAccount // 500) # -> 2
# 1100 = 500 * 2 + 100, so 1100 // 500 = integer division result = 2*
Shorter Code
# long version
savingsAccount = savingsAccount + 100

# equivalent short version
savingsAccount += 100
Naturally, there is a version for each arithmetic operator seen previously:
-=  for subtraction
*=  for multiplication
/=  for division
%=  for the remainder of the integer division

Let's Recap
In this chapter, you have learned the basics about variables:
A variable is made up of two parts: its name and its value.
Assigning a value to a variable is called an assignment.
The value of a variable can be changed.
The type of a variable depends on its value.
The names of your variables should be clear, explicit, and should follow a typographic convention.

Mix Several Numeric Variables
a = 7.5
b = 3
c = a/b
print(c)
# this will print 2.5, which is a float
a = 10
b = 5
c = a/b
print(c)
# it's a float

Concatenation:
However, you can force the conversion of a variable into a well-defined type. This is called typecasting because by doing so you are changing (casting) the type of a variable. To do this, you will need the corresponding functions:
a = 14.0
# a is a float
a = int(a)
print(a)
# a is now an integer: it prints 14 and not 14.0

Character Strings:
character strings are string types in Python, assembling several strings together is called concatenation. 

favoriteCityOne = "San Francisco"
favoriteCityTwo = "New York"
favorites = favoriteCityOne + favoriteCityTwo
print(favorites) # => "San FranciscoNew York"
favorites1 = "My favorite cities are " + favoriteCityOne + " and "+ favoriteCityTwo
print(favorites1) # -> "My favorite cities are San Francisco and New York"

However, you cannot concatenate other types of variables with strings, such as numeric variables---this would return an error. To remedy this, you will need to cast your numeric variable to a string, via the  str()  function:

city = "Sydney"
numberTrips = 5
history = "I've been to " + city + " " + str(numberTrips) + " times "
print(history) # => "I've been to Sydney 5 times"

Let's Recap:
There are three primitive types of variables, such as  integers, float, strings
We have also seen how to use these different types:
  You can perform numeric operations on numeric variables of different types.
  You can cast variables to force the transformation of the type of a variable into another specific type, according to your needs.
  Strings can be assembled together: this is called concatenation.

Function:
Functions can group several statements in a block which will be called using a name.
Functions are not specific to Python; they are present in all computer languages. They can:
reuse a portion of code already written just by stating the function name—so you don't have to rewrite the whole portion of code each time.
simplify code and make it more readable!

There are many pre-existing functions in Python! In addition to those already seen, there are, for example:
len() :  a function that returns the length of an item. Do you remember strings? Using this function on a string tells you how many characters the string contains.
type() : lets you print the type of a variable.
pow(a, b) : lets you calculate a to the power of b. It is equivalent to writing a**b.
abs() :  returns the absolute value of a number.
a="apple"
print(len(a)) #5
print(type(a)) #<class 'str'>
print(pow(4,2)) #16
print(abs(-100)) #100
Write your own function:
A function is defined via the keyword   def  followed by the name of the function. All the statements associated with this function will then be written after the colon.
def functionName():
    # statements
    # that can go
    # on several
    # lines
Note that all the statements associated with your function are offset in the code: this is called indentation.
Now define a function that would answer your problem:
def printPerimeter():
    dimension1 = 6
    dimension2 = 4
    dimension3 = 3
    perimeter = dimension1 + dimension2 + dimension3
    print(perimeter)
printPerimeter() # => 13
This function is correct, but not entirely useful: not all of your triangles will have the exact same dimensions.

Define the Parameters:
To overcome this limitation, you must make your function accept external numbers. You can do this by defining parameters.
In Python, parameters, just like the name of the function, are defined when the function is written. This is how it would look with the above example:
def printPerimeter(dimension1, dimension2, dimension3):
    perimeter = dimension1 + dimension2 + dimension3
    print(perimeter)
printPerimeter(10, 11, 4) # => 25
printPerimeter(2, 2, 3.5) # => 7.5
Parameters are variables declared in a function. The values that are passed as parameters are called arguments.
Often, when you use a function in a code, you expect an answer that you can reuse to move forward in the code. This answer can be provided via the value returned by a function.

Define a Return Value
To define a return value, you must explicitly use the return keyword at the end of your function.
You could change your   printPerimeter  function into   calculatePerimeter  which will return the perimeter of a triangle, according to the length of its three sides, so that it can be reused afterwards:
def calculatePerimeter(dimension1, dimension2, dimension3):
    perimeter = dimension1 + dimension2 + dimension3
    return perimeter
# Once you have defined your function, you can use it as many times as necessary:
perimeter1 = calculatePerimeter(6, 4, 3)
perimeter2 = calculatePerimeter(10, 3, 11)
print("The perimeter of my first triangle is", perimeter1, "and that of my second is", perimet

Use the help function if you forget:
Sometimes you often remember the name of a function, but not necessarily what it does or its arguments, etc. Don’t panic! The help function is there for that! If you run help(funtionName), this will print the documentation of this function summarizing:
its purpose.
recommendations for use.
the list and description of the parameters.
sometimes even examples.

Let's Recap
In this chapter we have learnt that:
functions can have parameters and return values.
a return value is the result of running the function. The return value is returned to the code that called the function, to be used as needed.
The parameters are the data necessary for a function to be run and generate a result.
parameters are variables defined by a name. Parameters are specified in the function declaration.
when using a function, you pass it different values as parameters. These values are called arguments.
you can use the help function to print the documentation of a given function.

OOPS:
Python is an object-oriented programming language—this means that in Python, everything is an object!
In programming, this concept of a group or category of objects is called a class. A class can be considered as the construction diagram for an object that will define the characteristics of all objects of this type and their features. From this class, you will be able to create different models of an object.
Let's take a concrete example with a Car class. The plan of a car can be defined by:
its characteristics, called attributes: it must have four wheels, a color, a shape, an engine power, etc.
its functionalities, called methods: it can drive, brake, etc.
So, from this plan, you can create different car models:
An ordinary family car, green, medium power (110 hp)
A sports car, red, relatively powerful (180 hp)
A small blue city car, not very powerful (90 hp)
etc.
And no matter what the car model, they are all capable of driving or braking, but not with the same performance!
In summary, a class is the outline of an object, defining its attributes and methods. From the same class, you can therefore create several objects of the same type, but with different attributes—these are called class instances.

Focus on Methods:
A class method is a function that is only available for the instances of this class. If, for example, we consider the Car class presented above having a drive() method, and a Plane class having a fly() method, you will agree quite logically that a plane can’t drive, and a car can’t fly. The same goes for our various objects!
The use of a method is always done via the   variableName.method()  notation. For example, strings have a method called   lower()  which will transform all the text contained in an object into lower case. Here's how to use it:

Strings Methods:
Python has implemented many methods to allow us to do all this. Here are the most common ones:
upper() :  returns the whole text in upper case.
lower(): returns the whole text in lower case.
capitalize() :  returns the whole text in lowercase with the first letter capitalized.
replace(old, new) :  this method takes two arguments: old and new, both of which are strings.  The method returns the original string with all occurrences of old replaced with new. 
find(string)  returns either the index of the first occurrence of the string passed in the  argument, or -1 if it does not find it.

Here are some examples of how these methods are used:
text = “here is an EXAMPLE of a STRING”
a = text.upper()
b = text.lower()
print(a)
print(b)
print(text.capitalize())
print(text.replace(‘EXAMPLE’, ‘test’))
print(text.find(‘an’)
print(text.find(‘two’)
Output:
HERE IS AN EXAMPLE OF A STRING
here is an example of a string
Here is an example of a string
Here is an test of a STRING
8
-1

Let's Recap:
A class is a construction plan for an object.
A variable is an instance of a class or an object.
An object is defined by its attributes.
All instances of a class have access to the same methods via the.  (dot) notation.
A method, like a function, generally does not modify the initial object.

Collections: Types => Lists and Dictionaries
If you want to analyze several customers at once, you can imagine that you need a variable for each customer. For the names, this could look like this:
customerName1 = 'Marion Weaver'
customerName2 = 'Alberto Mendoza'
customerName3 = 'Katharine Tyler'
customerName4 = 'Isaac Steele'
# etc.
If you have 10 customers to analyze, wouldn't it be easier to store them all in a single variable that would contain all the information?
You're in luck! Python offers a structure, a class capable of storing multiple pieces of information as a kind of array. This structure is called a list. Let's see how to use it.

Lists:
Lists are objects that can contain a collection of objects of any type. a list containing floats, a list containing strings, or even a list mixing objects of different types.
Lists are ordered objects, i.e., each item of the list is associated with a number corresponding to its order in the list. This number is called an index and it starts at 0 (not 1!). The first item is therefore associated with index 0, the second with index 1, etc.
Declaring a list is quite similar to the declaration of any variable seen so far: via a name to which we associate a list of items to be stored in this name.
For example, here is the list containing the names of four customers:
customerName = ['Marion Weaver', 'Alberto Mendoza', 'Katharine Tyler', 'Isaac Steele']
Now that your list is created, you can perform two basic operations:
Access a value at a given index
Change the value at a given index
In both cases, the code consists of the name of the variable followed by  [, the value of the index and  ].
For example, if you made a mistake on the name of the first customer and you want to correct their name:
# assign the value 'Marianne Weaver' to the first name in our list
# it is index 0, because indices start at 0 in python!
customerName[0] = 'Marianne Weaver'
To print it, you can write the following line:
print(customerName[0])

Python also lets you use negative indices to access or modify an item. The index -1 corresponds to the last item of the list, -2 to the second last, and so on. You can also access an index range by using the  :  operator. For example, 1:3 will let you access items two to four.
# print the last item
print(customerName[-1])

# access the second item to the 3rd
print(customerName[1:3])

# access all items from the beginning to the second
print(customerName[:2])
Here you have manipulated lists of strings, but you can do the same thing with the amount in each individual's account:
amountAccount = [10000, 150, 300, 1800.74]
For example, the following list is completely valid:
strangeList = [4, 10.2, 'Marion Weaver', ['another list', 1]]
# print the 4th item of the list
print(strangeList[3])

List Methods:
Here are some other methods that are essential to know about lists:
append(): to add the values in the list, and append() takes exactly one argument
insert  to insert a new item at a specific position. For example,   list.insert(1, 12)  will insert the integer 12 at index 1, moving the old item 1 to index 2 and so on.
extend :  similar to append, but with another list. This allows you to concatenate several lists together.
remove : searches for the given item in the list and deletes the first occurrence. For example, if you want to delete 5 from your list, you can use :  list.remove(5) .
index : this method lets you find the index of the first occurrence of an item to be searched for in our list;
Keyword  del  to delete an item according to its index.
Now let's try out some of these methods:
list = []
list.append(7) 		# -> [7]
list.append(5) 		# -> [7, 5]
list.insert(1,12) 		# [7, 12, 5]
list[0] = 4 		# -> [4, 12, 5]
list.remove(12) 		# [4, 5]
list.index(5) 		# prints 1
list.extend([1, 2, 3]) 	# [4, 5, 1, 2, 3]
del list[3] 		# [4, 5, 1, 3]

